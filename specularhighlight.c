// GENERATED BY CHATGPT, as a test
// TODO: yea ChatGPT couldn't 1-shot this.
// Unfortionate, it's faster to just do it myself.
// But maybe 4.0 will be able to make components in one shot?

#include <stdio.h>
#include <stdlib.h>

// C++ imports
#include <vector>
#include <cmath>

// module imports
#include <cairo.h>
#include <cairo-svg.h>
#include "geom.h"
#include "palette.h"
#include "render.h"
#include "brushes.h"
#include "constraints.h"

void highlightlambda(Segment s, Color color, double scale, double radius, double direction)
{
	// Find the center of the segment
	Vertex center = geom::centroid(s.boundary);

	// Create the drawing context
	cairo_t* drawer = cairo_create(s.canvas);

	// Draw the highlight
	double dx = radius * cos(direction * 2 * M_PI);
	double dy = radius * sin(direction * 2 * M_PI);
	double x = center.x * scale + dx;
	double y = center.y * scale + dy;

	cairo_set_line_width(drawer, 10.0);
	cairo_set_source_rgba(drawer, color.red, color.green, color.blue, 1);

	cairo_move_to(drawer, center.x * scale, center.y * scale);
	cairo_line_to(drawer, x, y);
	
	//printf("%f: %f,%f -> %f,%f\n",scale, center.x, center.y, x, y);
	
	cairo_stroke(drawer);

	cairo_destroy(drawer);
}

Callback specularhighlight(Workspace* ws, Segment s, Brush b)
{
	// Find color palette and decide if complexity is high enough
	double match = 1.0;
	uint32_t palette_mask = 0;
	auto palette_list = match_constraint("palette", s.constraint);
	for (auto m : palette_list) { palette_mask |= m.mask; }

	Palette palette = pick_palette(ws, palette_mask);
	Color color = pick_color(ws, &palette, s.constraint);

	// Find radius using the size constraint and area of the segment
	auto sizmatch = match_constraint("size", s.constraint);
	double radius = sqrt(area(s.boundary)) * distribution(sizmatch)(ws->rand);

	// Find direction using the lighting constraint
	auto lismatch = match_constraint("lighting", s.constraint);
	double direction = distribution(lismatch)(ws->rand);

	Callback ret
	{
		.usable = true,
		.match = match,
		.priority = b.priority,
		.callback = [=]() mutable -> void
		{
			highlightlambda(s, color, ws->scale(), radius, direction);
		}
	};
	return ret;
}

